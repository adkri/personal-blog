<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Personal blog of Amit Adhikari">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    
    <link rel="alternate icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/style.min.css">

    <title>Writing LRU Cache in C</title>
</head>
<body><header id="banner">
    <h2><a href="/">Amit Adhikari</a></h2>
    <nav>
        <ul>
            <li><a href="/">posts</a></li>
            
            <li>
                <a href="/about/">About Me</a>
            </li>
            
        </ul>
    </nav>
</header>
<main id="content">
<article>
    <header id="post-header">
        <h1>Writing LRU Cache in C</h1><time>March 13, 2019</time></header><p>In this post we will discuss the process of creating a Least Recently Used(LRU) cache structure in C. The Least Recently Used policy is very common model to create caching structures in computers.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)">LRU cache eviction policy</a> is as simple as it sounds. It describes the eviction strategy of data in a cache, in this case, if the cache requires to evict data it will evict the least recently used item.</p>
<p>Why and when would we need such a structure?</p>
<h4 id="cache">Cache</h4>
<p>First of all, let us define a cache. In computer science, a cache(pronounced &ldquo;cash&rdquo;) is simply a local data store we use to reduce data retrival time. While this concept might seem very simple, it is equally important in all levels of abstraction in a computer.</p>
<p>For example, in the computer hardware level we can store terabytes of information in a hard drive. However, the speed of the hard drive is slow and cannot compare to the operations a cpu can do within the same timeframe, so we put the running application on the RAM. Now, the cpu can work with data in the RAM instead of the hard drive. In this case, we can say the RAM is a &ldquo;cache&rdquo; for the hard drive.</p>
<p>Even in the software level, we have different caches. A cache to store the result of heavy computation, result of network calls, or data retrieved from the database.</p>
<p>By the nature of caching, we can see infer that it exists because we have finite memory at every level of abstraction we work on. Then we know that if we build a cache we should work on the assumption of limited memory available to us. Thus, we have the need for a cache eviction policy. Here, we define eviction as the removal of entries from the cache after it cannot store any more elements.</p>
<p>There are various different cache eviction strategies like First In First Out (FIFO), Least Recently Used (LRU), Most Frequently Used(MFU), or Random. Each one would be appropriate depending on requirements of the system.</p>
<h4 id="datastructure">Datastructure</h4>
<p>For our LRU cache, let us define the interface for it and then the internal design specifications that is required.</p>
<p>The cache itself should be very simple, supporting only the basic operations: <strong>get</strong> and <strong>put</strong>.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// Interface for the cache
</span><span class="c1"></span><span class="kt">void</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">key</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">put</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">key</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">value</span><span class="p">);</span>
</code></pre></div><p>Since the requirement from cache arises to make a current system faster, the time complexity should not be anything else than constant.</p>
<p>We see the cache interface resembles most closely to a hashtable structure found in most of computer science. So our implementation will include a hashtable with slight modifications. With a hashtable we have a basic cache, the ability to store and retrieve data. But to implement our eviction strategy, we need to remember the items that are being read and the items which are not being used. To perform such operations we implement a hashtable with a doubly linked list structure. The linked structure allows us to store data and move them around freely. This enables us to say, keep all the least used items at the tail of the list, while moving the used items to the front of the list. Then, we use hashtable to quickly jump around and get items from the list. Both of the operations can now be performed in constant time.</p>
<p>Implementation of the LRU Cache:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">key</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Node</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Node</span><span class="o">*</span> <span class="n">hashNext</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Node</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Table</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Table</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">List</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">tail</span><span class="p">;</span>
<span class="p">}</span> <span class="n">List</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">LRUCache</span> <span class="p">{</span>
    <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">;</span>
    <span class="n">List</span><span class="o">*</span> <span class="n">list</span><span class="p">;</span>
<span class="p">}</span> <span class="n">LRUCache</span><span class="p">;</span>
</code></pre></div><p>Now first lets make the methods to allocate space for these structures:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">Node</span><span class="o">*</span> <span class="nf">createNode</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">key</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">));</span>
    <span class="n">newNode</span> <span class="o">-&gt;</span> <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
    <span class="n">newNode</span> <span class="o">-&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">newNode</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">newNode</span> <span class="o">-&gt;</span> <span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">newNode</span> <span class="o">-&gt;</span> <span class="n">hashNext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">newNode</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Table</span><span class="o">*</span> <span class="nf">createTable</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Table</span><span class="o">*</span> <span class="n">newhash</span> <span class="o">=</span> <span class="p">(</span><span class="n">Table</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Table</span><span class="p">));</span>
    <span class="n">newhash</span> <span class="o">-&gt;</span> <span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>
    <span class="n">newhash</span> <span class="o">-&gt;</span> <span class="n">array</span> <span class="o">=</span> <span class="p">(</span><span class="n">Node</span><span class="o">**</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">)</span> <span class="o">*</span> <span class="n">capacity</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span> <span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">capacity</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">newhash</span> <span class="o">-&gt;</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">newhash</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">List</span><span class="o">*</span> <span class="nf">createList</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">List</span><span class="o">*</span> <span class="n">newList</span> <span class="o">=</span> <span class="p">(</span><span class="n">List</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">List</span><span class="p">));</span>
    <span class="n">newList</span> <span class="o">-&gt;</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">newList</span> <span class="o">-&gt;</span> <span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>
    <span class="n">newList</span> <span class="o">-&gt;</span> <span class="n">head</span> <span class="o">=</span> <span class="n">newList</span> <span class="o">-&gt;</span> <span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">newList</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">LRUCache</span><span class="o">*</span> <span class="nf">createCache</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LRUCache</span><span class="o">*</span> <span class="n">newCache</span> <span class="o">=</span> <span class="p">(</span><span class="n">LRUCache</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LRUCache</span><span class="p">));</span>   
    <span class="n">Table</span><span class="o">*</span> <span class="n">table</span> <span class="o">=</span> <span class="n">createTable</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">List</span><span class="o">*</span> <span class="n">list</span> <span class="o">=</span> <span class="n">createList</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="n">newCache</span> <span class="o">-&gt;</span> <span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>
    <span class="n">newCache</span> <span class="o">-&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">newCache</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>Now the function to add elements to our cache:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">put</span><span class="p">(</span><span class="n">LRUCache</span><span class="o">*</span> <span class="n">cache</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">key</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">valNode</span> <span class="o">=</span> <span class="n">createNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">addToHash</span><span class="p">(</span><span class="n">cache</span> <span class="o">-&gt;</span> <span class="n">table</span><span class="p">,</span> <span class="n">valNode</span><span class="p">))</span> <span class="c1">// already in list
</span><span class="c1"></span>        <span class="n">moveToFront</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">valNode</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="p">);</span>    
    <span class="k">else</span>
        <span class="n">addToList</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">valNode</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></div><p>Here we first create a Node so we can pass the same reference to the other functions.</p>
<p>We will call the <em>addToHash</em> function that add the entry to the cache. If the key already exists, it will update with new value and return <strong>1</strong>, otherwise it adds to the hashtable and returns <strong>0</strong>.</p>
<p>If the key was already there, we need to move it to the front of list with <em>moveToFront</em>. Or if we added new entry to the hashtable we also add it to list with <em>addToList</em>.</p>
<p>Now let&rsquo;s write the function definitions:</p>
<p><strong>addToHash</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">addToHash</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">valNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">size_t</span> <span class="n">hashCode</span> <span class="o">=</span> <span class="n">getHashCode</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">valNode</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="p">);</span>    
    <span class="k">if</span><span class="p">(</span><span class="n">table</span> <span class="o">-&gt;</span> <span class="n">array</span><span class="p">[</span><span class="n">hashCode</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// check if is in hash
</span><span class="c1"></span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">hashCode</span><span class="p">];</span>

        <span class="k">while</span><span class="p">(</span><span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">hashNext</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="p">,</span> <span class="n">valNode</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="n">valNode</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="p">;</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span> 
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">hashNext</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// last node
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="p">,</span> <span class="n">valNode</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="n">valNode</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="p">;</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> 

        <span class="c1">// add after last node
</span><span class="c1"></span>        <span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">hashNext</span> <span class="o">=</span> <span class="n">valNode</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">table</span> <span class="o">-&gt;</span> <span class="n">array</span><span class="p">[</span><span class="n">hashCode</span><span class="p">]</span> <span class="o">=</span> <span class="n">valNode</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><strong>moveToFront</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">moveToFront</span><span class="p">(</span><span class="n">LRUCache</span><span class="o">*</span> <span class="n">cache</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Table</span><span class="o">*</span> <span class="n">table</span> <span class="o">=</span> <span class="n">cache</span> <span class="o">-&gt;</span> <span class="n">table</span><span class="p">;</span>
    <span class="n">List</span><span class="o">*</span> <span class="n">list</span> <span class="o">=</span> <span class="n">cache</span> <span class="o">-&gt;</span> <span class="n">list</span><span class="p">;</span>

    <span class="c1">// return if only element in list
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">list</span> <span class="o">-&gt;</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> 
        <span class="k">return</span><span class="p">;</span>

    <span class="n">size_t</span> <span class="n">hashCode</span> <span class="o">=</span> <span class="n">getHashCode</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">table</span> <span class="o">-&gt;</span> <span class="n">array</span><span class="p">[</span><span class="n">hashCode</span><span class="p">];</span>

    <span class="c1">// find in hashMap
</span><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">hashNext</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// return if doesn&#39;t exist
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">curr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="c1">// move curr to latest/tail of list
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">prev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// if head in list
</span><span class="c1"></span>        <span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">tail</span><span class="p">;</span>
        <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">head</span> <span class="o">=</span> <span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">next</span><span class="p">;</span>
        <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">head</span> <span class="o">-&gt;</span> <span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">tail</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
        <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
        <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">tail</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="c1">// already latest at tail
</span><span class="c1"></span>        <span class="k">return</span><span class="p">;</span>
    
    <span class="c1">// if curr in middle
</span><span class="c1"></span>    <span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">-&gt;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">prev</span><span class="p">;</span>
    <span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">prev</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">next</span><span class="p">;</span> 
    <span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">tail</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
    <span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">tail</span><span class="p">;</span>
    <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div><p><strong>addToList</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">addToList</span><span class="p">(</span><span class="n">LRUCache</span><span class="o">*</span> <span class="n">cache</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">valNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">List</span><span class="o">*</span> <span class="n">list</span> <span class="o">=</span> <span class="n">cache</span> <span class="o">-&gt;</span> <span class="n">list</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">list</span> <span class="o">-&gt;</span> <span class="n">size</span> <span class="o">==</span> <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">capacity</span><span class="p">)</span>
        <span class="n">evictCache</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">list</span> <span class="o">-&gt;</span> <span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">head</span> <span class="o">=</span> <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">valNode</span><span class="p">;</span>
        <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   
        <span class="k">return</span><span class="p">;</span> 
    <span class="p">}</span>
    
    <span class="n">valNode</span> <span class="o">-&gt;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">tail</span><span class="p">;</span>
    <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">tail</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">valNode</span><span class="p">;</span>
    <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">valNode</span><span class="p">;</span>
    <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">size</span> <span class="o">=</span> <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>We see that we evict the cache if the size of list reaches the capacity. Lets write that out too.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">evictCache</span><span class="p">(</span><span class="n">LRUCache</span><span class="o">*</span> <span class="n">cache</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Table</span><span class="o">*</span> <span class="n">table</span> <span class="o">=</span> <span class="n">cache</span> <span class="o">-&gt;</span> <span class="n">table</span><span class="p">;</span>
    <span class="n">List</span><span class="o">*</span> <span class="n">list</span> <span class="o">=</span> <span class="n">cache</span> <span class="o">-&gt;</span> <span class="n">list</span><span class="p">;</span>

    <span class="n">Node</span><span class="o">*</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">head</span><span class="p">;</span>
    <span class="c1">// return if empty
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">list</span> <span class="o">-&gt;</span> <span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="c1">// remove head and tail if only one node
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">list</span> <span class="o">-&gt;</span> <span class="n">head</span> <span class="o">==</span> <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span>  <span class="p">{</span>
        <span class="c1">// remove entry from list with multiple nodes
</span><span class="c1"></span>        <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">head</span> <span class="o">=</span> <span class="n">entry</span> <span class="o">-&gt;</span> <span class="n">next</span><span class="p">;</span>
        <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">size</span> <span class="o">=</span> <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">head</span> <span class="o">-&gt;</span> <span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
        
    <span class="c1">// remove from map
</span><span class="c1"></span>    <span class="n">size_t</span> <span class="n">hashCode</span> <span class="o">=</span> <span class="n">getHashCode</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">entry</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="p">);</span>
    <span class="n">Node</span><span class="o">**</span> <span class="n">indirect</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">hashCode</span><span class="p">];</span> 
    <span class="k">while</span><span class="p">((</span><span class="o">*</span><span class="n">indirect</span><span class="p">)</span> <span class="o">!=</span> <span class="n">entry</span><span class="p">)</span>
        <span class="n">indirect</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">indirect</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="o">*</span><span class="n">indirect</span> <span class="o">=</span> <span class="n">entry</span> <span class="o">-&gt;</span> <span class="n">next</span><span class="p">;</span>

    <span class="n">free</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>Another function we keep using is the <em>getHashCode</em> which takes a char buffer and returns a index in the table. We will use a simple implementation of a hashing function for this.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">size_t</span> <span class="nf">getHashCode</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">source</span><span class="p">)</span> <span class="p">{</span>    
    <span class="k">if</span> <span class="p">(</span><span class="n">source</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">source</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">source</span><span class="o">++</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
        <span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span>     
    <span class="p">}</span> 
    <span class="k">return</span> <span class="n">hash</span> <span class="o">%</span> <span class="n">table</span> <span class="o">-&gt;</span> <span class="n">capacity</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>Now that we are able to add entries to the cache, lets write the function to retrieve entries.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">char</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="n">LRUCache</span><span class="o">*</span> <span class="n">cache</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Table</span><span class="o">*</span> <span class="n">table</span> <span class="o">=</span> <span class="n">cache</span> <span class="o">-&gt;</span> <span class="n">table</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">hashCode</span> <span class="o">=</span> <span class="n">getHashCode</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span>  <span class="n">table</span> <span class="o">-&gt;</span> <span class="n">array</span><span class="p">[</span><span class="n">hashCode</span><span class="p">];</span>
    <span class="k">while</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">moveToFront</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">hashNext</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>And thats it. Lets test this in the main function.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">cacheSize</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">LRUCache</span><span class="o">*</span> <span class="n">cache</span> <span class="o">=</span> <span class="n">createCache</span><span class="p">(</span><span class="n">cacheSize</span><span class="p">);</span>

    <span class="n">put</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="s">&#34;a&#34;</span> <span class="p">,</span> <span class="s">&#34;b&#34;</span><span class="p">);</span>
    <span class="n">put</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="s">&#34;c&#34;</span> <span class="p">,</span> <span class="s">&#34;d&#34;</span><span class="p">);</span>
    <span class="n">put</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="s">&#34;e&#34;</span> <span class="p">,</span> <span class="s">&#34;f&#34;</span><span class="p">);</span>
    <span class="n">put</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="s">&#34;g&#34;</span> <span class="p">,</span> <span class="s">&#34;h&#34;</span><span class="p">);</span>
    <span class="n">put</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="s">&#34;c&#34;</span> <span class="p">,</span> <span class="s">&#34;z&#34;</span><span class="p">);</span>
    <span class="n">put</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="s">&#34;e&#34;</span> <span class="p">,</span> <span class="s">&#34;y&#34;</span><span class="p">);</span>

    <span class="n">get</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="s">&#34;c&#34;</span><span class="p">);</span>

    
    <span class="c1">// print the cache contents from lru to mru
</span><span class="c1"></span>    <span class="n">Node</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">cache</span> <span class="o">-&gt;</span> <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cache</span> <span class="o">-&gt;</span> <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s %s </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">temp</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="p">,</span> <span class="n">temp</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="p">);</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">-&gt;</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>And this is the output.</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">g h 
e y 
c z 
</code></pre></div><p>You can find the entire source code at <a href="https://github.com/adkri/lrucache">github</a>.</p>
</article>

        </main><footer id="footer">
    <div>


        <a href="https://github.com/adkri">github</a>
        |
        <a href="https://twitter.com/amitadkri">twitter</a>
        |
        <a href="/index.xml">rss</a>
    </div>
    
</footer>
</body>
</html>
